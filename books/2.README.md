Laravel  API 

## REST API について

API を作成する。シンプルなメッセージ API の作成

```
Route::get("status", function(){
    return [
      "status" => "OK"
      "message" => "no issues with systemn"
    ];
});
```

これで簡単な API の作成は完了です。

ブラウザで `/api/status` にアクセスすることで、API の結果を確認することができます。

:::
`routes/api.php` 内で作成された REST API は URL に `/api/` のプレフィックスが付与されます。
この設定は後述する REST API の設定で変更が可能です。

### REST API の確認

実際に API の作成ができたら、ツールを利用した API の動作確認方法を理解しておきましょう。

`GET` メソドを利用した API はブラウザからもその動作を確認できますが、 `POST` メソドを利用したAPIや パラメータの送信が必要なAPIはブラウザ上で動作確認を行うのが困難です。

REST API は curl コマンドや、各種プログラム用のライブラリなどから通信を行うことができる他、GUI のツールを用いて 動作を確認することもできます。

先程作成した API の動作を、Postman と呼ばれる API クライアントツールを用いて確認してみましょう。

TODO POSTMANの使いかた加筆

## REST API の設計

API を構築する上では、リクエストとレスポンスについて考える。

### レスポンス

一般的に API のレスポンスは、JSON 形式で送信されます。

Laravel では ルートの処理内で、return 文を用いて 配列を返した場合、自動的に配列が JSON形式に変換されて レスポンスとして生成されます。

```
Route::get("status", function(){
    return [
      "status" => "OK"
      "message" => "no issues with systemn"
    ];
});
```

レスポンスには、メインの情報である レスポンスボディの他に、ステータスコードやヘッダといった情報を返却することもできます。

- ステータスコード： API の結果の形式を、数値で表す
- レスポンスヘッダ： API の補足的な情報を表現する

ステータスコードは、HTTP通信においては、成功なら 200  のステータスコード

レスポンスヘッダは、API 通信における補足的な返却情報です。例えばユーザの一覧を返却する API において、レスポンスボディで JSON 形式のユーザリストを返却する場合に、ページングの情報を レスポンスヘッダで返すなどします。

ステータスコードやレスポンスヘッダを ルート内で定義する場合には以下のように `response` 関数を利用して レスポンスを作成します。

```
Route::get("status", function(){

    return response([],200,$headers);
});
```

### リクエスト

通信元からのアクセス情報をリクエストと呼びます。

API を構築する場合、リクエストの形式として URL だけでなく リクエストメソドについても考える必要があります。

Web ページのリクエストではでは、 GET / POST の メソドが用いられること一般的ですが、 API ではそれを拡張して以下の様なメソドが利用されます。

- GET
- POST
- PUT
- PATCH
- DELETE

リクエストメソドを定義する場合には、Route クラスを利用して、、、、

```php

```

`GET` 以外のメソドでは、リクエストボディとしてパラメータを付与する事ができます。リクエストボディの値は `Request` クラス　や `request` 関数を用いて取得することができます。

また、API 通信では、認証やメタ情報を ヘッダを用いて送信することもあります。ヘッダの値は `Request` クラス　や `request` 関数を用いて取得することができます。

```php

```

## REST API の設定

`routes/api.php` 内で作成された REST API は URL に `/api/` のプレフィックスが付与されます。

API の動作設定は、 `hoge` に記述されており

prefix は 

## ADR パターンの適用

一般的な Laravel での システム開発では MVC と呼ばれる設計の考え方が参照されますが、
API 開発においては ビュー部分のロジックは 「見た目」よりも API のレスポンス全体を意識したものが多くなってきます。

API の設計においては MVC パターンよりも ADR と呼ばれる、MVC 派生の設計モデルを利用する方がマッチするでしょう。

ADR は Action-Domain-Responder の略称で、 システムの構造を Action Domain Responder の３つに分割して捉えます。

### Action

Action は MVC でいうところの Controller に相当する部分です。

MVC の Controller と違って Action は アクションクラスと言う形で、１クラスで １つの API エンドポイントを担当します。

Controller が複数の URL を管理しながら Controller 内で 共通のロジックを取りまとめていた部分は Domain と呼ばれる Model 層に取りまとめられています。

Action は Domain 層からデータを受け取って最終的に Responder を呼出して レスポンスを生成します。

Action クラスは 以下のような形で実装します。

```

```

実装された Action クラスをルートで利用する場合には、以下のような形になるでしょう。

```

```

また `__invoke` を利用して クラスそのものをルートとすることも可能です。

```

```

上記のような アクションクラスを作成した場合には、ルートの記述は以下のような形になります。

```

```

### Domain

Domain は MVC でいうところの Model に相当する部分です。

ドメイン層の構造は、作ろうとするシステムによって様々ですが、
Repository パターンを適用したり Clean アーキテクチャを適用したり、設計は様々です。

### Responder

Responder は MVC でいうところの View に相当する部分です。

MVC の View と違って Responder は Response 全般を管理します。すなわち、レスポンスボディだけでなく、ステータスコードやレスポンスヘッダの生成などを広く管理するクラス、ということになります。

Action と一対一で紐付けるように作成する場合は以下のような Responder が作成できるでしょう。

Action 側から利用する際には以下のようなコードとなります。

また Action と 一対一の Responder を個別に作成するのが面倒な場合でも、以下のような汎用的な Responder を生成して、 Response の生成を一つの場所にまとめておくのはとても重要なことです。


これを、Action 側から利用する際には以下のようなコードとなります。

# API と認証

ページを作成する Laravel アプリケーションがセッションを利用した認証管理を行うのとは対象的に、API を使った認証では トークンベースでの ユーザ認証が行われます。

トークンベースでのユーザ認証では、ログインのタイミングでユーザに対して認証用のトークンを発行します。

トークンを受け取ったクライアントは、発行されたトークンを持って API を発行することで API 発行者が誰なのかを認証させることができます。

## 認証を実装する

認証を実装する前に、ユーザのテーブルを作成して テストのユーザ情報をいくつか格納してみましょう。

ここでは Laravel で デフォルトの migration 情報として登録されている `users` テーブルの情報を利用します。

追加でトークンを保持するためのテーブルを以下のような形で作成してみましょう。

ユーザをいくつか用意するために、以下のようなテスト用の Seeder を作成します。

```

```

パスワードの情報は 平文で保存するのではなく暗号化して保存しておく方が良いでしょう。
ここでは Laravel の Hash 機能を利用してデータの暗号化を行っています。

`php artisan db:seed` コマンドを実行すると、テストデータが Database 内に格納され認証機能を利用する準備ができました。

### 認証トークンの発行

まずはログインの処理を実装してみましょう。

`POST /api/login` のリクエストでユーザ認証を行える　API を作成してみましょう。

ログインのための Email と password は `credential.email` `credential.password` の形式で渡します。

```

```

`$request->get()` で認証情報を受け取って該当するユーザを検索しています。

該当するユーザが見つかったら トークン情報を Database に格納してレスポンスとして返却します。

トークンはランダムな英数字であれば何でも構いませんが、生成のフローが推測されないものを用いる必要があります。

Laravel では ランダムな 英数字を生成する際に `hoge` と言った関数が利用できる他、…

### 認証の実施

発行されたトークンを利用してユーザ情報が識別できるかを確認するために、次は認証情報のプロフィールを表示する `GET /profile/me` のAPI を作成してみましょう。

ログイン API から受け取ったトークンは ヘッダを経由して `TOKEN: XXXXXX` の形式で送るものとします。

```

```

ヘッダで送信されたデータは `$request->get("TOKEN")` の形式で取得することができます。

リクエストデータから取得されたトークンを利用して、ユーザの検索を行い該当のユーザが存在すればそのタイミングでユーザ情報を返却しています。

これで 認証付き API を作成する事ができました！

REST API 通信においてトークンの 渡し方は様々ですが、
一般的には Bearer 方式と呼ばれるものが利用されます。
Bearer 方式では ヘッダを用いて `Authorization: Bearer XXXXXX` の形式でトークンが渡されます。

この方式で トークンを渡す場合、コードは以下のような形で変更になります。

```

```

Laravel では Bearer 方式でのトークン受け渡しに対応するための、`$request->bearerToken()` という関数が用意されているため、これを利用することで簡単に Beaerer 方式のトークンをリクエストから取得する事が可能です。

### ログアウトの実装

ログアウトの実装 トークンを削除するだけ

## Laravel の認証フロー

上記のような認証処理をすべての認証付き API で実装するのはとても面倒です。

実際のシステム開発の現場では、Laravel の認証フローに載せて認証情報を管理するほうが、
様々なメンバーとのやり取りの上でも便利でしょう。

Laravel の 認証について理解する上では、以下のような概念を整理しておく必要があります。

- Guard : 
- Provider : 

### トークン認証の設定を行う

### APIにトークン認証の設定をかける


# Laravel における DI の活用

DI は Laravel における重要な機能の一つです。

シンプルなアプリケーションを構築する上で DI の活用は欠かせません。

## DI の活用

アクションクラスを利用して DI の活用方法を紹介する。

商品一覧を取ってくる

```
Route::get("items", function(){
    return [
      "status" => "OK"
      "message" => "no issues with systemn"
    ];
});
```

ここでは 商品一覧の取得や Responder の呼出しが Action クラス内で直接行われています。

これを DI する形で記述したコードは以下の形になります。

```

```

この様に、引数に必要なモジュールの情報を記述すると Laravel がそのモジュールの生成時や関数の実行時に必要とされているモジュールを自動的に生成して 引数として渡してくれます。
この「必要なモジュールが外部から渡される仕組み」を DI (依存性の注入)と呼びます。

## DI によるオブジェクト生成のフック

Laravel の DI を利用する場合、 Service Provider 経由で注入されるモジュールの生成管理を行うことができます。

通常 DI で記述されたモジュールは  Laravel 側で勝手に `new` 演算子が実行されてインスタンスが生成されます。
Service Provider はこうしたモジュールの生成を管理するための機能を与えてくれています。

```

```

`singleton` は DI コンテナ上にモジュールを登録する際の一般的な記述方法です。第一引数にモジュール名を、第二引数にモジュール生成時の処理を記述します。

`siingleton` 経由でDI コンテナに登録されたモジュールの生成処理は、実際にモジュールが利用される際にのみ実行されます。また一度生成されたモジュールはリクエストの間キャッシュされるため、複数箇所からモジュールの参照があった場合でも、生成処理は一度しか実行されません。

ServiceProvider 上でのモジュールの生成管理は、複雑で重たいモジュールの生成処理を共通化したい、といったケースや、モジュールの生成時に必要な引数やオプション値の管理を一元化したいなど、様々なケースで活用する事ができるでしょう。

モジュール生成後の処理に対してフックを入れることも可能です。

```

```

`extend` では、引数として生成されたモジュールを

### 独自の Service Provider の利用

## インターフェイスを利用した実装

DI コンテナを活用することで インターフェイスの機能を最大限活用する事ができるようになります。




# REST API のテストと API 仕様の作成

作成した REST API を使って実際にテストを記述してみましょう。




01/31 Laravel による REST API 開発
基本の API 開発 と Middleware の仕組みを解説します。 CORS 対応や telescoope を利用したデバッグのフローを紹介します。

02/07 Laravel における認証
REST API における認証のフローを解説します。

02/14 Laravel におけるDIの活用
Laravel における DI コンテナ の活用手法について紹介します。 Service Provider などを通じて分離度の高いモジュールを設計する事ができるようになります。

02/21 REST API のテストと API 仕様の作成
Laravel における REST API のテストや Swagger を用いた API 仕様書の作成・活用フローを紹介します。




